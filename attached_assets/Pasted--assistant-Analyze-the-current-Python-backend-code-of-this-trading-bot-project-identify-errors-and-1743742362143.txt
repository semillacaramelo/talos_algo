@assistant Analyze the current Python backend code of this trading bot project, identify errors, and implement necessary corrections to ensure the core functionality runs correctly. The goal is to have a runnable `src/main.py` that integrates the ML model, options trading logic, and contract monitoring.

**Context:**
- Previous steps attempted to refactor the bot into a class (`TradingBot`), integrate ML model loading (`RandomForestClassifier` + scaler), implement enhanced feature engineering (including RSI, ATR, Stoch, MACD), switch trading logic to Digital Options (`proposal`->`buy`), and add contract monitoring (`proposal_open_contract`).
- The UI (`app.py`, templates, static) exists but backend integration might be incomplete or incorrect. Focus on fixing the Python backend logic first.
- Errors related to imports, async handling, variable scope, feature calculation, API calls, and state management are likely present.

**Step-by-Step Analysis and Correction Plan:**

1.  **Analyze Imports & Paths:**
    - **Check:** Review imports across all relevant Python files (`src/main.py`, `src/api/deriv_api_handler.py`, `src/data/data_handler.py`, `src/models/signal_model.py`, `src/utils/logger.py`, `src/utils/backtest.py`, `src/train_model.py`, `src/ml_backtest.py`, `app.py`). Correct any `ModuleNotFoundError` or incorrect relative/absolute imports.
    - **Verify `sys.path`:** Ensure any necessary `sys.path` modifications in `src/main.py` or elsewhere are correct for the Replit environment, or advise if running with `PYTHONPATH` is necessary.

2.  **Verify ML Model Loading & Feature Engineering:**
    - **Check `src/models/signal_model.py` -> `train_or_load_model`:** Ensure it correctly loads *both* `basic_predictor.joblib` (RandomForest) and `scaler.joblib` using correct paths relative to the file. Verify robust error handling (returns `None, None` or similar on failure).
    - **Check `src/models/signal_model.py` -> `engineer_features`:** Verify this function calculates *all* intended features (price changes, MA diff, RSI, ATR, Stoch, MACD) using `pandas-ta` where applicable. Ensure `dropna()` is called correctly *after* all calculations. Check for potential errors if input DataFrame is too small.
    - **Check `src/models/signal_model.py` -> `FEATURE_COLUMNS`:** Verify this global list **exactly matches** the feature names generated by `engineer_features` and expected by the trained model.

3.  **Verify ML Signal Generation & Integration:**
    - **Check `src/models/signal_model.py` -> `generate_signal`:**
        - Confirm it receives the model and scaler objects.
        - Confirm it calls `engineer_features`.
        - Confirm it correctly selects features using `FEATURE_COLUMNS`.
        - Confirm it applies the `scaler` (if loaded) using `scaler.transform()`.
        - Confirm it calls `model.predict()` on the prepared features.
        - Confirm it correctly maps the prediction (0/1) to SELL/BUY signals.
        - Verify error handling around these steps.
    - **Check `src/main.py` -> `main()`:** Confirm it loads the model/scaler *once* at startup and passes them correctly down through the subscription chain (`subscribe_to_ticks` -> `handle_tick`).
    - **Check `src/api/deriv_api_handler.py` -> `subscribe_to_ticks`:** Confirm it accepts `model_ref` and `scaler_ref` and passes them correctly when scheduling `handle_tick` via `asyncio.create_task`.
    - **Check `src/main.py` -> `handle_tick()`:** Confirm its signature accepts the model/scaler and passes them to `generate_signal`.

4.  **Verify Options Trading Logic:**
    - **Check `src/main.py` -> `handle_tick()`:**
        - When a BUY signal occurs, verify it correctly calls `get_option_proposal` with `contract_type="CALL"` and other parameters from `config/settings.py`.
        - When a SELL signal occurs, verify it correctly calls `get_option_proposal` with `contract_type="PUT"`.
        - Verify it correctly extracts the `proposal_id` and `ask_price` from a *successful* proposal response.
        - Verify it correctly calls `buy_option_contract` with the extracted `proposal_id` and `ask_price`.
        - Verify appropriate logging for each step.

5.  **Verify Contract Monitoring & State Management:**
    - **Check `src/main.py` -> `handle_tick()`:** Verify that after a successful `buy_option_contract` call, it retrieves the `contract_id` and calls `subscribe_to_contract_updates`.
    - **Check `src/api/deriv_api_handler.py` -> `subscribe_to_contract_updates`:** Verify it correctly subscribes using `proposal_open_contract: 1` and the `contract_id`. Crucially, verify it uses the `asyncio.create_task(on_update_callback(message))` pattern for the `on_next` handler to avoid await warnings.
    - **Check `src/main.py` -> `handle_contract_update()`:** Verify it correctly parses the incoming message, checks for `is_sold == 1`, logs profit/loss, finds the corresponding entry in the `active_contracts` dictionary, calls `dispose()` on the stored disposable, and then removes the entry from `active_contracts`.
    - **Check `src/main.py`:** Verify `active_contracts` is used for the `MAX_CONCURRENT_TRADES` check. Verify the `finally` block correctly iterates `active_contracts` to dispose of any remaining subscriptions *before* calling `disconnect`.

6.  **Check Basic Risk Management Placeholders:**
    - **Verify `src/main.py` -> `handle_tick()`:** Confirm the *structure* for dynamic stake calculation (fetching balance - might need adding the `api.balance` call logic here or in `handle_contract_update`) and the check for `daily_pnl < -MAX_DAILY_LOSS` are present, even if the implementation details need refinement. Ensure necessary state variables (`daily_pnl`) are defined globally or within the class scope.

7.  **Test Execution & Debugging Cycle:**
    - **Action:** Execute the main script using the command: `python -u src/main.py` (or `PYTHONPATH=. python -u src/main.py` if imports fail).
    - **Analyze Output:** Carefully read any `Traceback` or error messages printed in the console or logs.
    - **Apply Fixes:** Based on the error messages and the verification steps above, implement the necessary code corrections.
    - **Repeat:** Re-run the script after applying fixes. Continue this cycle until the bot starts, connects, loads the model, subscribes to ticks, processes ticks, correctly generates an ML signal (BUY or SELL), successfully places at least one option trade (proposal + buy), subscribes to its updates, and eventually logs the contract finishing, removing it from the state, *without crashing or printing critical Python errors*. (Minor warnings like the shutdown one are lower priority for now).

**Final Goal:** Achieve a state where `src/main.py` runs without immediate crashes and demonstrates the core loop (tick -> feature -> predict -> signal -> propose -> buy -> monitor -> close state) working correctly for at least one trade cycle based on the integrated ML model. Focus on backend stability and correctness first.