@assistant Analyze the current Python backend AND Flask frontend code of this trading bot project. Identify and correct errors in both, ensuring the Flask UI (`app.py`, templates, static files) correctly controls and monitors the Python trading bot (`src/` directory code). The final goal is a runnable web application where the UI reflects the bot's state and actions.

**Context:**
- A Flask UI skeleton (`app.py`, `templates/index.html`, `static/`) was previously generated.
- The Python trading bot backend (in `src/`) was refactored into a `TradingBot` class and integrated with ML model loading/prediction and options trading logic.
- Errors are likely present in the Python backend (imports, async, logic) AND in the integration between Flask (`app.py`) and the `TradingBot` class, including potentially incorrect handling of asynchronous bot operations within the synchronous Flask framework.

**Step-by-Step Analysis and Correction Plan:**

**PART 1: Ensure Python Backend Stability (Focus on `src/` directory)**

1.  **Analyze Imports & Paths:**
    - **Check:** Review imports across all relevant Python files (`src/main.py`, `src/api/...`, `src/data/...`, `src/models/...`, `src/utils/...`, `src/train_model.py`, `src/ml_backtest.py`). Correct `ModuleNotFoundError` or path issues.
    - **Verify:** Ensure code assumes it's run relative to the project root or uses appropriate relative paths (e.g., for loading models in `src/models/`).

2.  **Verify ML Model & Features:**
    - **Check `src/models/signal_model.py`:** Verify `train_or_load_model` loads the `RandomForestClassifier` and scaler. Verify `engineer_features` calculates all intended features (price changes, MA diff, RSI, ATR, Stoch, MACD) matching `train_model.py`. Verify `FEATURE_COLUMNS` list is correct. Verify `generate_signal` uses these components correctly and applies the scaler. **Remove all placeholder feature code/comments.**

3.  **Verify Options Trading Logic:**
    - **Check `src/main.py` (likely within `TradingBot` class now):** Verify the `proposal -> buy` sequence for "CALL" (BUY signal) and "PUT" (SELL signal) options using `get_option_proposal` and `buy_option_contract`. Ensure parameters from `config/settings.py` are used.

4.  **Verify Contract Monitoring:**
    - **Check `src/api/deriv_api_handler.py` -> `subscribe_to_contract_updates`:** Confirm it uses `asyncio.create_task` for the `on_next` callback to avoid await warnings.
    - **Check `src/main.py` (within `TradingBot` or `handle_contract_update`):** Confirm it correctly processes `proposal_open_contract` messages, checks `is_sold`, logs P/L, disposes the specific contract subscription, and removes the entry from the `active_contracts` state dictionary.

5.  **Verify Basic Risk Placeholders:**
    - **Check `src/main.py` (within `TradingBot` class):** Confirm the structure exists for dynamic stake calculation (may need adding `api.balance` call) and the daily loss limit check (`if daily_pnl < -MAX_DAILY_LOSS`).

6.  **Test Backend Standalone (Optional but Recommended):**
    - **Action:** *Temporarily* modify the `if __name__ == "__main__":` block in `src/main.py` to instantiate `TradingBot` and call `asyncio.run(bot.start())` followed by a short sleep and `asyncio.run(bot.stop())`.
    - **Execute:** Run `python -u src/main.py`.
    - **Debug:** Fix any Python errors that arise *before* proceeding to UI integration. Revert the `if __name__ == "__main__":` block afterwards.

**PART 2: Integrate Backend with Flask UI (Focus on `app.py`, `static/script.js`)**

7.  **Verify Bot Instantiation (`app.py`):**
    - Ensure a single instance of the `TradingBot` class (imported from `src.main`) is created globally in `app.py`.

8.  **Implement Asynchronous Task Handling in Flask:**
    - **Problem:** Flask is synchronous, the bot is asynchronous (`asyncio`). Directly calling `await bot.start()` or `asyncio.run(bot.stop())` within Flask routes will block the server.
    - **Solution (Instruct Assistant):** Refactor the `/start_bot` and `/stop_bot` routes to run the bot's async methods in a separate thread or using an asyncio event loop managed alongside Flask.
        - **Option A (Threading):** Use Python's `threading` module:
          ```python
          import threading
          import asyncio
          # ... (in /start_bot)
          if not bot.is_running(): # Assuming bot has is_running state
              threading.Thread(target=lambda: asyncio.run(bot.start()), daemon=True).start()
              # ... return success
          # ... (in /stop_bot)
          if bot.is_running():
              # Stopping might need care - ensure thread safety if state is shared
              threading.Thread(target=lambda: asyncio.run(bot.stop()), daemon=True).start() 
              # ... return success
          ```
        - **Option B (Checking Replit Default):** Ask the Assistant: "How does the standard Replit Python Flask template recommend running background asyncio tasks? Implement the standard Replit approach for `/start_bot` and `/stop_bot` routes to call `bot.start()` and `bot.stop()` asynchronously without blocking Flask."
    - **Verify:** Ensure starting/stopping the bot via UI buttons doesn't freeze the web server.

9.  **Implement Status Endpoint (`/get_status` in `app.py`):**
    - **Action:** Ensure this route correctly calls methods/accesses attributes on the `bot` instance (e.g., `bot.is_running`, `bot.get_balance()`, `len(bot.active_contracts)`) and fetches static config from `config.settings`.
    - **Return:** Verify it returns a JSON matching the structure expected by the frontend JS. Add error handling in case the bot state isn't ready.

10. **Implement Log Streaming (`/stream_logs` in `app.py` & Logger):**
    - **Check Logger (`src/utils/logger.py`):** Confirm `setup_logger` writes logs to a shared mechanism accessible by Flask (e.g., an `asyncio.Queue` passed during setup, or a simple global `collections.deque`).
    - **Check Route (`app.py`):** Verify the `/stream_logs` route uses Server-Sent Events (SSE preferred) or long polling to read from the shared queue/deque and send *new* log lines to the frontend.

11. **Verify Frontend JavaScript (`static/script.js`):**
    - **Check Fetch Calls:** Ensure button clicks correctly call `fetch('/start_bot')` and `fetch('/stop_bot')`.
    - **Check Status Updates:** Verify the periodic `fetch('/get_status')` updates the text content of `#status-display`, `#balance-value`, `#active-trades-value`, `#instrument-value`, etc.
    - **Check Log Updates:** Verify the JS connects to `/stream_logs` (using `EventSource` if SSE) and *appends* new log messages to the `#log-output` textarea, implementing auto-scrolling if possible.

**PART 3: End-to-End Testing & Debugging**

12. **Run the Full Application:**
    - **Action:** Use Replit's "Run" button (which should typically start the Flask server defined in `app.py`).
    - **Interact:** Open the web preview. Click "Start Bot". Observe the UI status display and log output. Let it run. Try placing a trade by waiting for an ML signal. Observe active trades count. Click "Stop Bot".
    - **Analyze:** Check the Flask server console in Replit *and* the `logs/bot.log` file for any errors (Python errors, Flask errors, JavaScript console errors in the browser's developer tools).
    - **Debug:** Provide specific errors to the Assistant/Agent for targeted fixes. For example: "The start button click gives a 500 error in Flask, here is the traceback..." or "The balance value in the UI is not updating, check the `/get_status` route and the corresponding JS".
    - **Iterate:** Repeat running, testing UI interactions, and debugging until the UI reliably controls the bot, displays accurate status, and shows updating logs.

**Final Goal:** A working web application in Replit where the user can start/stop the ML-powered trading bot, see its live status (running/stopped, balance, active trades), view configuration, and monitor its activity through streamed logs.